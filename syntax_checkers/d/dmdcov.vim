"============================================================================
"File:        dmdcov.vim
"Description: Coverage checker by using existing files generated by 'dmd -cov'
"Maintainer:  Joakim Brännström <joakim dot brannstrom at gmx dot com>
"License:     This program is free software. It comes without any warranty,
"             to the extent permitted by applicable law. You can redistribute
"             it and/or modify it under the terms of the Do What The Fuck You
"             Want To Public License, Version 2, as published by Sam Hocevar.
"             See http://sam.zoy.org/wtfpl/COPYING for more details.
"
"============================================================================
" User:
" g:syntastid_d_dmdcov_external_configure (default off), let the user control
" project_dir and report_dir.
" g:syntastic_d_dmdcov_project_dir, the project directory dmd is ran from.
" g:syntastic_d_dmdcov_report_dir, the directory the coverage reports are
" stored in.
" The Vim event that is triggered before any parsing of coverage report,
" Syntastic_d_pre_DMDcov.
" The configurable parameters for grep are, with prefix syntastic_d_dmd_:
" <exe> <args> <fname> <post_args> <tail>
"
" Note: The checker uses grep to retrieve all lines that has zero coverage.
"
" Design.
" Efficiency:
" By default the checker do not produce any .lst-files. It merely looks for
" the existence of .lst-files in the current work directory.
" Why?
" It would be prohibitory slow to run dmd followed by the whole test suite
" each time the user saves the current buffer.
"
" Usability:
" It should be as easy as possible for the user to use the checker but still
" keep the checker simple/dumb.
" The checker therefore has two modes, simple and external.
"
" The simple mode assumes that the coverage files are in the project root.
" It allows the user to do a simple :cd project/root and this checker will
" then "just work".
"
" The external mode allows for those scenarios where the user have the
" coverage files separated from the project directory.
"
if exists('g:loaded_syntastic_d_dmdcov_checker')
    finish
endif
let g:loaded_syntastic_d_dmdcov_checker = 1

if !exists('g:syntastic_d_dmdcov_external_configure')
    let g:syntastic_d_dmdcov_external_configure = 0
endif

if !exists('g:syntastic_d_dmdcov_errorformat')
    let g:syntastic_d_dmdcov_errorformat = '%l:%m'
endif

if !exists('g:syntastic_d_dmdcov_active')
    let g:syntastic_d_dmdcov_active = 1
endif

let s:save_cpo = &cpo
set cpo&vim

function! s:_calculate_cov_fname(project_dir, report_dir, source_file)
    let result = a:source_file
    let result = strpart(l:result, strlen(a:project_dir))
    " remove leading /
    let result = substitute(result, '\v^\/*', '', 'g')
    " replace / with -
    let result = substitute(result, '\v\/', '-', 'g')

    return a:report_dir . '/' . result
endfunction

function! s:_replace_zeroes(errors) abort " {{{2
    for e in a:errors
        let e['text'] = 'Missing coverage'
    endfor

    return a:errors
endfunction " }}}2

function! SyntaxCheckers_d_dmdcov_IsAvailable() dict
    if !exists('g:syntastic_d_dmdcov_exe')
        let g:syntastic_d_dmdcov_exe = expand('grep', 1)
    endif
    if !exists('g:syntastic_d_dmdcov_project_dir')
        let g:syntastic_d_dmdcov_project_dir = expand('%:p:h')
    endif

    if !exists('g:syntastic_d_dmdcov_report_dir')
        let g:syntastic_d_dmdcov_report_dir = expand('%:p:h')
    endif

    call self.log('g:syntastic_d_dmdcov =', g:syntastic_d_dmdcov_exe)
    return executable(g:syntastic_d_dmdcov_exe)
endfunction

function! SyntaxCheckers_d_dmdcov_GetLocList() dict
    silent doautocmd User Syntastic_d_pre_DMDcov

    " allow the user to turn on/off
    if !g:syntastic_d_dmdcov_active
        return []
    endif

    let source_file = expand('%:p:r') . '.lst'

    if g:syntastic_d_dmdcov_external_configure
        let fname = s:_calculate_cov_fname(g:syntastic_d_dmdcov_project_dir,
                    \ g:syntastic_d_dmdcov_report_dir, source_file)
    else "fallback
        let cwd = getcwd()
        let fname = s:_calculate_cov_fname(cwd, cwd, source_file)

        " if dmd ran with a path that started with ./ it would expand to .-.
        " Assuming it is a common case so therefore handling it in fallback
        " mode.
        if !filereadable(fname)
            let source_file = expand('%:p:h') . '/./' . expand('%:p:t:r') . '.lst'
            let fname = s:_calculate_cov_fname(cwd, cwd, source_file)
        endif
    endif

    let makeprg = self.makeprgBuild({
                \ "args": '-s -n -o "^0000000" -- ',
                \ "fname": syntastic#util#shexpand(fname)})

    let errors = SyntasticMake({
        \ 'makeprg': makeprg,
        \ 'errorformat': g:syntastic_d_dmdcov_errorformat,
        \ 'defaults': {'type': 'w', 'bufnr':bufnr('')},
        \ 'subtype': 'Style' })

    return s:_replace_zeroes(errors)
endfunction

call g:SyntasticRegistry.CreateAndRegisterChecker({
    \ 'filetype': 'd',
    \ 'name': 'dmdcov'})

let &cpo = s:save_cpo
unlet s:save_cpo

" vim: set sw=4 sts=4 et fdm=marker:
